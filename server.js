import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import http from 'http';
import { Server } from 'socket.io';
import fs from 'fs';
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const app = express();
const server = http.createServer(app);
const io = new Server(server, { cors: { origin: '*' } });
app.use(express.json());
app.use('/cards', express.static(path.join(__dirname, 'public', 'cards')));
app.use('/assets', express.static(path.join(__dirname, 'public', 'assets')));
app.use(express.static(path.join(__dirname, 'dist')));
let CARDS = { divines: [], followers: [] };
try{ CARDS = JSON.parse(fs.readFileSync(path.join(__dirname,'src','data','cards.js')).toString().replace(/^\s*export default\s*/,'').trim()); }catch(e){ console.warn('cards not loaded',e.message); }
function findCard(id){ return (CARDS.divines.find(d=>d.id===id) || CARDS.followers.find(f=>f.id===id)); }
function decodeDeck(code){ try{ let pad = code.length%4; if(pad) code += '='.repeat(4-pad); return JSON.parse(Buffer.from(code,'base64').toString('utf8')); }catch(e){return null;} }
const rooms = {};
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
function newGameState(){ return { players:{}, order:[], decks:{A:[],B:[]}, discards:{A:[],B:[]}, started:false, table:[], confirms:{} }; }
function summarize(roomId){ const r=rooms[roomId]; if(!r) return null; const players=Object.entries(r.players).map(([id,p])=>({id,name:p.name,hand:p.hand,engage:p.engage,divine:p.divine,divineHP:p.divineHP,runes:p.runes,transcended:p.transcended})); return {id:roomId,players,deckCounts:{A:r.decks.A.length,B:r.decks.B.length},discardCounts:{A:r.discards.A.length,B:r.discards.B.length},table:r.table}; }
io.on('connection', socket=>{ console.log('conn',socket.id);
  socket.on('createRoomPrivate', ({roomId, deckCode}, cb)=>{ if(!roomId||!deckCode) return cb&&cb({error:'roomId and deckCode required'}); if(rooms[roomId]) return cb&&cb({error:'room exists'}); const arr=decodeDeck(deckCode); if(!arr) return cb&&cb({error:'invalid deck code'}); const divine=arr[0]; const followers=arr.slice(1); const r=newGameState(); r.decks.A=shuffle(followers.slice()); r.players[socket.id]={id:socket.id,name:'Player',hand:[],engage:null,divine,divineHP:(findCard(divine)||{}).hp||30,runes:{fire:0,water:0,grass:0},transcended:false,drawn:0}; r.order.push(socket.id); rooms[roomId]=r; socket.join(roomId); io.to(roomId).emit('roomUpdate',summarize(roomId)); cb&&cb({ok:true}); });
  socket.on('joinRoom', ({roomId, deckCode}, cb)=>{ const r=rooms[roomId]; if(!r) return cb&&cb({error:'room not found'}); if(!deckCode) return cb&&cb({error:'deckCode required'}); if(Object.keys(r.players).length>=2) return cb&&cb({error:'room full'}); const arr=decodeDeck(deckCode); if(!arr) return cb&&cb({error:'invalid deck code'}); const divine=arr[0]; const followers=arr.slice(1); r.decks.B=shuffle(followers.slice()); r.players[socket.id]={id:socket.id,name:'Player',hand:[],engage:null,divine,divineHP:(findCard(divine)||{}).hp||30,runes:{fire:0,water:0,grass:0},transcended:false,drawn:0}; r.order.push(socket.id); socket.join(roomId); io.to(roomId).emit('roomUpdate',summarize(roomId)); cb&&cb({ok:true}); if(Object.keys(r.players).length===2) startMatch(roomId); });
  socket.on('createRoomWithDeck', ({roomId, name, deckCode}, cb)=>{ const arr=decodeDeck(deckCode); if(!arr) return cb&&cb({error:'invalid deck code'}); const divine=arr[0]; const followers=arr.slice(1); const r=newGameState(); r.decks.A=shuffle(followers.slice()); const botDivs=CARDS.divines.map(d=>d.id).filter(x=>x!==divine); const botDiv=botDivs[Math.floor(Math.random()*botDivs.length)]; const pool=CARDS.followers.map(f=>f.id); shuffle(pool); r.decks.B=pool.slice(0,15); r.players[socket.id]={id:socket.id,name:name||'Player',hand:[],engage:null,divine,divineHP:(findCard(divine)||{}).hp||30,runes:{fire:0,water:0,grass:0},transcended:false,drawn:0}; const botId='BOT_'+Math.random().toString(36).slice(2,8); r.players[botId]={id:botId,name:'Bot',hand:[],engage:null,divine:botDiv,divineHP:(findCard(botDiv)||{}).hp||30,runes:{fire:0,water:0,grass:0},transcended:false,drawn:0}; r.order.push(socket.id); r.order.push(botId); rooms[roomId]=r; socket.join(roomId); startMatch(roomId); io.to(roomId).emit('roomUpdate',summarize(roomId)); cb&&cb({ok:true}); });
  socket.on('playerConfirm', ({roomId, card}, cb)=>{ const r=rooms[roomId]; if(!r) return cb&&cb({error:'room not found'}); if(!r.players[socket.id]) return cb&&cb({error:'not in room'}); const p=r.players[socket.id]; if(!p.hand.includes(card)) return cb&&cb({error:'card not in hand'}); const idx=p.hand.indexOf(card); p.hand.splice(idx,1); p.engage=card; r.confirms[socket.id]=card; io.to(roomId).emit('roomUpdate',summarize(roomId)); const humanIds=Object.keys(r.players).filter(id=> !r.players[id].isBot); if(humanIds.length===2 && humanIds.every(id=> r.confirms[id])){ resolveEngage(roomId); r.confirms={}; } cb&&cb({ok:true}); });
  socket.on('disconnecting', ()=>{ for(const roomId of Object.keys(socket.rooms)){ const r=rooms[roomId]; if(!r) continue; delete r.players[socket.id]; const idx=r.order.indexOf(socket.id); if(idx!==-1) r.order.splice(idx,1); io.to(roomId).emit('roomUpdate',summarize(roomId)); if(Object.keys(r.players).length===0) delete rooms[roomId]; } });
  function resolveEngage(roomId){ const r=rooms[roomId]; if(!r) return; const engages=Object.entries(r.players).filter(([id,p])=>p.engage).map(([id,p])=>({id,card:p.engage})); if(engages.length<2) return; const totals={}; const elements={}; for(const e of engages){ const info=findCard(e.card); totals[e.id]=(totals[e.id]||0)+(info.attack||0); elements[e.id]=elements[e.id]||new Set(); if(info.element) elements[e.id].add(info.element); r.players[e.id].runes[info.element]=(r.players[e.id].runes[info.element]||0)+1; r.players[e.id].drawn=(r.players[e.id].drawn||0)+1; } let winner=null; let best=-1; let tie=false; for(const id of Object.keys(totals)){ const v=totals[id]||0; if(v>best){ best=v; winner=id; tie=false } else if(v===best) tie=true } if(tie||winner===null){ r.table.push({system:'Round tied â€” no damage'}); finalizeEngageAndDraw(r); return; } const opponent=Object.keys(r.players).find(id=> id!==winner); let attackValue=totals[winner]||0; let runeBonus=0; for(const el of elements[winner]||[]) runeBonus += (r.players[winner].runes[el]||0); const winnerDiv=findCard(r.players[winner].divine); let damage=attackValue + runeBonus; if(winnerDiv && winnerDiv.id==='D1' && r.players[winner].transcended && r.players[winner].transcended_effect && r.players[winner].transcended_effect.type==='double_damage'){ damage = damage*2; } r.players[opponent].divineHP -= damage; r.table.push({system:`${r.players[winner].name} won the clash and dealt ${damage} damage to ${r.players[opponent].name}`}); // abilities winner then loser
  for(const e of engages.filter(x=>x.id===winner)){ const info=findCard(e.card); if(info.abilities) for(const ab of info.abilities){ applyAbility(r,winner,opponent,ab); } }
  for(const e of engages.filter(x=>x.id===opponent)){ const info=findCard(e.card); if(info.abilities) for(const ab of info.abilities){ applyAbility(r,opponent,winner,ab); } }
  checkTranscend(r,winner); checkTranscend(r,opponent); finalizeEngageAndDraw(r); if(r.players[opponent].divineHP<=0){ r.table.push({system:`${r.players[winner].name} wins the match!`}); r.started=false; io.to(roomId).emit('roomUpdate',summarize(roomId)); setTimeout(()=>{ delete rooms[roomId]; },3000); return; } io.to(roomId).emit('roomUpdate',summarize(roomId)); }
  function finalizeEngageAndDraw(r){ for(const [id,p] of Object.entries(r.players)){ if(p.engage){ const key=r.order.indexOf(id)===0?'A':'B'; r.discards[key].push(p.engage); p.engage=null; } } for(const id of Object.keys(r.players)){ drawToPlayer(r,id,1); } }
  function applyAbility(r,actorId,targetId,ab){ const actor=r.players[actorId]; const target=r.players[targetId]; if(ab.type==='draw'){ drawToPlayer(r,actorId,ab.value||1); r.table.push({system:`${actor.name} drew ${ab.value||1} card(s) via ability`}); } else if(ab.type==='damage'){ const dmg=ab.value||1; target.divineHP-=dmg; r.table.push({system:`${actor.name} dealt ${dmg} damage via ability to ${target.name}`}); } else if(ab.type==='discard'){ const amt=ab.value||1; for(let i=0;i<amt;i++){ if(target.hand.length===0) break; const ri=Math.floor(Math.random()*target.hand.length); const removed=target.hand.splice(ri,1)[0]; const key=r.order.indexOf(targetId)===0?'A':'B'; r.discards[key].push(removed); r.table.push({system:`${actor.name} forced ${target.name} to discard ${removed}`}); const tdiv=findCard(r.players[targetId].divine); if(tdiv && r.players[targetId].transcended && r.players[targetId].transcended_effect && r.players[targetId].transcended_effect.type==='double_discard'){ if(target.hand.length>0){ const ri2=Math.floor(Math.random()*target.hand.length); const removed2=target.hand.splice(ri2,1)[0]; r.discards[key].push(removed2); r.table.push({system:`Discard triggered twice: ${target.name} discarded ${removed2}`}); } } } } 
  function drawToPlayer(r,playerId,count){ const idx=r.order.indexOf(playerId); const key=idx===0?'A':'B'; for(let i=0;i<count;i++){ if(r.decks[key].length===0){ if(r.discards[key].length>0){ r.decks[key]=shuffle(r.discards[key].splice(0)); } } if(r.decks[key].length===0) break; const c=r.decks[key].pop(); r.players[playerId].hand.push(c); r.players[playerId].drawn=(r.players[playerId].drawn||0)+1; } }
  function checkTranscend(r,playerId){ const p=r.players[playerId]; if(!p) return; if(p.transcended) return; const dv=findCard(p.divine); if(!dv) return; const cond=dv.transcend; if(cond.startsWith('runes>=')){ const num=parseInt(cond.split('>=')[1],10); const total=(p.runes.fire||0)+(p.runes.water||0)+(p.runes.grass||0); if(total>=num){ p.transcended=true; p.transcended_effect=dv.transcendEffect; r.table.push({system:`${p.name}'s Divine ${dv.name} has transcended!`}); } } else if(cond.startsWith('damageInTurn>=')){ const num=parseInt(cond.split('>=')[1],10); const dmg=r.damageThisTurn&&r.damageThisTurn[playerId]||0; if(dmg>=num){ p.transcended=true; p.transcended_effect=dv.transcendEffect; r.table.push({system:`${p.name}'s Divine ${dv.name} has transcended!`}); } } else if(cond.startsWith('drawn>=')){ const num=parseInt(cond.split('>=')[1],10); if((p.drawn||0) >= num){ p.transcended=true; p.transcended_effect=dv.transcendEffect; r.table.push({system:`${p.name}'s Divine ${dv.name} has transcended!`}); if(dv.transcendEffect && dv.transcendEffect.type==='set_rune_to_6'){ const keys=['fire','water','grass']; let best='fire'; let bestv=p.runes.fire||0; for(const k of keys){ if((p.runes[k]||0)>bestv){ best=k; bestv=p.runes[k]||0 } } p.runes[best]=6; r.table.push({system:`${p.name}'s Divine sets ${best} rune to 6 permanently.`}); } } } }
  function startMatch(roomId){ const r=rooms[roomId]; if(!r) return; r.started=true; r.table=[]; r.confirms={}; r.discards={A:[],B:[]}; r.damageThisTurn={}; // draw 5 for each and give divine's element rune
    for(const id of r.order){ const p=r.players[id]; p.hand=[]; p.engage=null; p.runes={fire:0,water:0,grass:0}; p.transcended=false; p.transcended_effect=null; p.drawn=0; const key=r.order.indexOf(id)===0?'A':'B'; // draw 5
      for(let i=0;i<5;i++){ if(r.decks[key].length===0){ if(r.discards[key].length>0) r.decks[key]=shuffle(r.discards[key].splice(0)); } if(r.decks[key].length===0) break; p.hand.push(r.decks[key].pop()); p.drawn++; }
      const dv=findCard(p.divine); if(dv && dv.element) p.runes[dv.element]=(p.runes[dv.element]||0)+1; p.divineHP=(dv&&dv.hp)?dv.hp:30; }
    io.to(roomId).emit('roomUpdate',summarize(roomId)); }
});
const PORT=process.env.PORT||3000; server.listen(PORT,()=>console.log('Server listening on',PORT));
